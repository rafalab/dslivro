# Visualização de dados na prática {#gapminder}

Neste capítulo, demonstraremos como códigos relativamente simples usando __ggplot2__ podem criar gráficos esclarecedores e esteticamente agradáveis. Como motivação, criaremos gráficos que nos ajudarão a entender melhor as tendências da saúde e da economia global. Vamos implementar o que aprendemos nos capítulos \@ref(ggplot2) e \@ref(other-geometries) e aprenderemos a expandir os códigos para aperfeiçoar os gráficos criados. À medida que prosseguimos em nosso estudo de caso, descreveremos os princípios gerais mais relevantes para a visualização de dados e aprenderemos conceitos como _faceting_, _gráficos de séries temporais_, _transformações_ e _gráficos de ridge_.


## Estudo de caso: novas perspectivas sobre pobreza

Hans Rosling^[https://pt.wikipedia.org/wiki/Hans_Rosling] foi co-fundador da Fundação Gapminder^[http://www.gapminder.org/], uma organização dedicada a educar o público através de dados para dissipar mitos comuns sobre o chamado mundo em desenvolvimento. A organização usa dados para mostrar como as tendências atuais nos campos da saúde e da economia contradizem as narrativas emanadas da cobertura sensacionalista da mídia sobre catástrofes, tragédias e outros eventos desafortunados. Conforme declarado no site da Fundação Gapminder:

>>> Jornalistas e lobistas contam histórias dramáticas. Esse é o trabalho deles. Eles contam histórias sobre eventos extraordinários e pessoas incomuns. As pilhas de histórias dramáticas se acumulam na mente das pessoas gerando visões de mundo excessivamente dramáticas, estresse e fortes sentimentos negativos: "O mundo está ficando pior!", "Somos nós contra eles!", "Outras pessoas são estranhas!", "A população continua crescendo!" e "Ninguém liga!"

Hans Rosling decidiu, de maneira dramática, educar o público sobre tendências reais orientadas a dados usando visualizações eficazes. Esta seção é baseada em duas palestras que exemplificam essa perspectiva educacional: _Novas Perspectivas Sobre a Pobreza_^[https://www.ted.com/talks/hans_rosling_reveals_new_insights_on_poverty?language=pt] e _As Melhores Estatísticas Jamais Vistas_^[https://www.ted.com/talks/hans_rosling_shows_the_best_stats_you_ve_ever_seen?language=pt]. Especificamente, nesta seção, usamos dados para tentar responder às duas perguntas a seguir:

1. É uma caracterização justa dizer que, nos dias de hoje, o mundo está dividido em nações ocidentais ricas e nações em desenvolvimento na África, Ásia e América Latina?
2. A desigualdade de renda piorou em todos os países nos últimos 40 anos?

Para responder a essas perguntas, usaremos a base de dados `gapminder` fornecida pelo __dslabs__. Esse _dataset_ foi criado usando diversas planilhas disponibilizadas pela Fundação Gapminder. Você pode acessar essa tabela desta maneira:

```{r load libraries, message=FALSE, echo=TRUE}
library(tidyverse)
library(dslabs)
data(gapminder)
gapminder %>% as_tibble()
```

### Teste de Hans Rosling

Assim como na apresentação em vídeo _Novas Perspectivas Sobre a Pobreza_, começamos testando nossos conhecimentos sobre as diferenças na mortalidade infantil em diferentes países. Para cada um dos cinco pares de países abaixo, quais deles você imagina que tiveram as maiores taxas de mortalidade infantil em 2015? Quais pares você acha que são mais parecidos?

1. Sri Lanka ou Turquia
2. Polônia ou Coréia do Sul
3. Malásia ou Rússia
4. Paquistão ou Vietnã
5. Tailândia ou África do Sul

Ao responder a essas perguntas sem dados, os países não europeus geralmente são escolhidos como os que apresentam as mais altas taxas de mortalidade infantil: Sri Lanka sobre a Turquia, Coreia do Sul sobre Polônia e Malásia sobre Rússia. Também é comum supor que os países considerados parte do mundo em desenvolvimento - Paquistão, Vietnã, Tailândia e África do Sul - têm taxas de mortalidade igualmente altas.

Para responder a essas perguntas __com dados__, podemos usar __dplyr__. Por exemplo, para a primeira comparação, vemos que:

```{r, message=FALSE}
gapminder %>%
filter(year == 2015 & country %in% c("Sri Lanka","Turkey")) %>%
select(country, infant_mortality)
```
A Turquia tem a maior taxa de mortalidade infantil.

Podemos usar esse código em todas as comparações e descobrir o seguinte:
```{r, echo = FALSE}
comp_table <- tibble(comparison = rep(1:5, each = 2),
country = c("Sri Lanka", "Turkey", "Poland", "South Korea", "Malaysia", "Russia", "Pakistan","Vietnam","Thailand","South Africa"))

tmp <- gapminder %>%
filter(year == 2015) %>%
select(country, infant_mortality) %>%
mutate(country = as.character(country)) ##to match characters to characters

tab <- inner_join(comp_table, tmp, by = "country") %>% select(-comparison)

tmp <- bind_cols(slice(tab,seq(1,9,2)), slice(tab,seq(2,10,2)))
names(tmp) <- c("country", "infant mortality", "country", "infant mortality")
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Vemos que os países europeus desta lista têm taxas de mortalidade infantil mais altas: a Polônia tem uma taxa mais alta do que a Coreia do Sul e a Rússia tem uma taxa mais alta que a Malásia. Também vemos que o Paquistão tem uma taxa muito mais alta do que o Vietnã e a África do Sul tem uma taxa muito mais alta do que a Tailândia. Acontece que, quando Hans Rosling deu esse teste para grupos de pessoas instruídas, a pontuação média foi inferior a 2,5 em 5, pior do que eles teriam obtido se tivessem apenas chutado as respostas. Isso implica que, mais do que ignorantes, estamos mal informados. Neste capítulo, vemos como a visualização dos dados ajuda a nos informar.


## Diagramas de dispersão (_scatterplots_)

A razão disso decorre da noção preconcebida de que o mundo está dividido em dois grupos: o mundo ocidental (Europa Ocidental e América do Norte), caracterizado por uma longa expectativa de vida e famílias pequenas, versus o mundo em desenvolvimento (África, Ásia e América Latina), caracterizada por uma curta expectativa de vida e famílias numerosas. Mas os dados suportam essa visão dicotômica?

Os dados necessários para responder a essa pergunta também estão disponíveis em nossa tabela `gapminder`. Usando nossas habilidades de visualização de dados recém-aprendidas, podemos enfrentar esse desafio.

Para analisar essa visão de mundo, nosso primeiro plote é um gráfico de dispersão da expectativa de vida versus taxas de fertilidade (número médio de filhos por mulher). Começamos analisando os dados de cerca de 50 anos atrás, quando talvez essa visão tenha sido consolidada em nossas mentes.

```{r fertility-versus-life-expectancy-1962, warning=FALSE}
filter(gapminder, year == 1962) %>%
ggplot(aes(fertility, life_expectancy)) +
geom_point()
```

A maioria dos pontos se enquadra em duas categorias diferentes:

1. Expectativa de vida em torno de 70 anos e 3 ou menos filhos por família.
2. Expectativa de vida menor que 65 anos e mais de 5 filhos por família.

Para confirmar que esses países são das regiões que esperamos, podemos usar cores para representar os continentes.

```{r fertility-versus-life-expectancy-1962-with-color}
filter(gapminder, year == 1962) %>%
ggplot( aes(fertility, life_expectancy, color = continent)) +
geom_point()
```

Em 1962, a visão do "Ocidente versus mundo em desenvolvimento" era baseada em uma certa realidade. Será que ainda é assim 50 anos depois?

## Separe em facetas

Podemos facilmente representar graficamente os dados de 2012 da mesma maneira que fizemos em 1962. No entanto, para comparação, é preferível representar graficamente lado a lado. No __ggplot2__, conseguimos isso separando as variáveis em _facets_: estratificamos os dados por alguma variável e fazemos o mesmo gráfico para cada estrato.

Para separar em facetas, adicionamos uma camada com a função `facet_grid`, que separa automaticamente os gráficos. Essa função permite separar até duas variáveis em facetas usando colunas para representar uma variável e linhas para representar a outra. A função espera que as variáveis de linha e coluna sejam separadas por um `~`. Aqui vemos um exemplo de um diagrama de dispersão em que adicionamos `facet_grid` como a última camada:

```{r fertility-versus-life-expectancy-facet, warning=FALSE, out.width="100%"}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_grid(continent~year)
```

Acima, vemos um gráfico para cada combinação de continente/ano. No entanto, este exemplo apresenta mais do que queremos, que é simplesmente comparar dois anos: 1962 e 2012. Nesse caso, existe apenas uma variável. Podemos usar `.` para que `facet_grid` saiba que queremos usar todas as variáveis:

```{r fertility-versus-life-expectancy-two-years, warning=FALSE, out.width="100%", fig.height=3}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_grid(. ~ year)
```

Este gráfico mostra claramente que a maioria dos países mudou do cluster de _países em desenvolvimento_ para o cluster de _países ocidentais_. Em 2012, a visão do mundo ocidental versus o mundo em desenvolvimento não faz mais sentido. Isso é particularmente evidente ao comparar a Europa com a Ásia, este último agora inclui vários países que apresentaram grandes melhorias.

### `facet_wrap`

Para explorar como essa transformação ocorreu ao longo dos anos, podemos fazer o gráfico para vários anos. Por exemplo, podemos adicionar os anos 1970, 1980, 1990 e 2000. No entanto, se fizermos isso, não queremos todos os gráficos na mesma linha, que é o que faz `facet_grid` por padrão, pois eles parecerão muito estreitos para exibir os dados. Em vez disso, queremos usar várias linhas e colunas. A função `facet_wrap` nos permite fazer isso automaticamente, acomodando a série de gráficos para que cada imagem tenha dimensões visíveis:


```{r fertility-versus-life-expectancy-five-years, out.width="100%"}
years <- c(1962, 1980, 1990, 2000, 2012)
continents <- c("Europe", "Asia")
gapminder %>%
filter(year %in% years & continent %in% continents) %>%
ggplot( aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_wrap(~year)
```

Este gráfico mostra claramente como a maioria dos países asiáticos melhorou a uma taxa muito mais rápida que os países europeus.

### Escalas fixas para melhores comparações

A escolha padrão da faixa de eixos é importante. Quando não estiver usando`facet`, esse intervalo é determinado pelos dados mostrados no gráfico. Usando `facet`, esse intervalo é determinado pelos dados exibidos em todos os gráficos e, portanto, permanece fixo em todas os plotes. Isso facilita muito nas comparações entre gráficos. Por exemplo, no gráfico acima, podemos ver que a expectativa de vida aumentou e a fertilidade diminuiu na maioria dos países. Vemos isso porque a nuvem de pontos está se movendo. Este não é o caso se ajustarmos as escalas:

```{r facet-without-fixed-scales, warning=FALSE}
filter(gapminder, year%in%c(1962, 2012)) %>%
ggplot(aes(fertility, life_expectancy, col = continent)) +
geom_point() +
facet_wrap(. ~ year, scales = "free")
```

No gráfico acima, devemos prestar atenção especial ao intervalo para observar que o gráfico à direita tem uma expectativa de vida mais longa.

## Gráficos de séries temporais

As visualizações acima ilustram efetivamente que os dados não são mais consistentes com a visão de mundo ocidental versus o mundo em desenvolvimento. Vendo esses gráficos, novas questões surgem. Por exemplo, quais países estão melhorando mais e quais são os menos? A melhoria foi constante nos últimos 50 anos ou acelerou mais em determinados períodos? Para uma análise mais detalhada que possa ajudar a responder a essas perguntas, apresentamos gráficos de séries temporais.

Os gráficos de séries temporais possuem tempo no eixo x e um resultado ou medida de interesse no eixo y. Por exemplo, aqui está um gráfico da tendência nas taxas de fertilidade nos Estados Unidos:

```{r fertility-time-series-plot-points, warning=FALSE}
gapminder %>%
filter(country == "United States") %>%
ggplot(aes(year, fertility)) +
geom_point()
```

Observamos que a tendência não é linear, mas que durante os anos sessenta e setenta há uma queda acentuada abaixo de 2. Em seguida, a tendência retorna a 2 e se estabiliza nos anos noventa.

Quando os pontos são espaçados regularmente e densamente, como vemos acima, criamos uma curva que conecta os pontos às linhas, para transmitir que esses dados são provenientes de uma única série, aqui um país. Para fazer isso, usamos a função `geom_line` em vez de `geom_point`.

```{r fertility-time-series-plot-curve, warning=FALSE}
gapminder %>%
filter(country == "United States") %>%
ggplot(aes(year, fertility)) +
geom_line()
```

Isso é particularmente útil ao comparar dois países. Se criarmos um subconjunto dos dados para incluir dois países, um da Europa e outro da Ásia, adaptaremos o código acima:

```{r wrong-time-series-plot, warning=FALSE, message=FALSE}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries) %>%
ggplot(aes(year,fertility)) +
geom_line()
```

Claramente, esse __not__ é o gráfico que queremos. Em vez de uma linha para cada país, os pontos dos dois países são unidos porque não informamos `ggplot` que queremos duas linhas independentes. Para que `ggplot` para entender que existem duas curvas que devem ser feitas separadamente, atribuímos cada ponto a uma `group`, um para cada país:


```{r time-series-two-curves, warning=FALSE, message=FALSE}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
ggplot(aes(year, fertility, group = country)) +
geom_line()
```

Mas qual linha vai com qual país? Podemos atribuir cores para fazer essa distinção.
Um efeito colateral útil do uso do argumento `color` para atribuir cores diferentes a diferentes países, os dados são agrupados automaticamente:

```{r fertility-time-series-plot}
countries <- c("South Korea","Germany")

gapminder %>% filter(country %in% countries & !is.na(fertility)) %>%
ggplot(aes(year,fertility, col = country)) +
geom_line()
```

O gráfico mostra claramente como a taxa de fertilidade da Coréia do Sul caiu drasticamente durante as décadas de 1960 e 1970, e em 1990 teve uma taxa semelhante à da Alemanha.

### Etiquetas em vez de legendas

Para gráficos de tendências, recomendamos rotular as linhas em vez de usar legendas, pois o espectador pode ver rapidamente qual linha representa qual país. Essa sugestão se aplica à maioria dos gráficos: os rótulos geralmente são preferidos às legendas.

Demonstramos como fazer isso usando dados de expectativa de vida. Definimos uma tabela de dados com os locais dos rótulos e, em seguida, usamos uma segunda atribuição apenas para esses rótulos:

```{r labels-better-than-legends}
labels <- data.frame(country = countries, x = c(1975,1965), y = c(60,72))

gapminder %>%
filter(country %in% countries) %>%
ggplot(aes(year, life_expectancy, col = country)) +
geom_line() +
geom_text(data = labels, aes(x, y, label = country), size = 5) +
theme(legend.position = "none")
```

O gráfico mostra claramente como uma melhoria na expectativa de vida se seguiu a quedas nas taxas de fertilidade. Em 1960, os alemães viveram 15 anos a mais que os sul-coreanos, embora em 2010 a diferença esteja completamente fechada. Ele exemplifica a melhoria que muitos países não ocidentais fizeram nos últimos 40 anos.



## Transformações de dados

Agora voltamos nossa atenção para a segunda questão relacionada à idéia comum de que a distribuição da riqueza em todo o mundo piorou nas últimas décadas. Quando se pergunta ao público em geral se os países pobres se tornaram mais pobres e os países ricos se tornaram mais ricos, a maioria responde que sim. Usando camadas, histogramas, densidades suaves e gráficos de caixa, podemos ver se esse é realmente o caso. Primeiro, aprenderemos como as transformações às vezes podem ajudar a fornecer resumos e gráficos mais informativos.

A tabela de dados `gapminder` inclui uma coluna com o produto interno bruto do país, ou PIB. O PIB mede o valor de mercado de bens e serviços produzidos por um país em um ano. O PIB por pessoa é frequentemente usado como um resumo aproximado da riqueza de um país. Aqui, dividimos esse valor por 365 para obter a medida mais interpretável de _dólares por dia_. Usando o dólar atual como unidade, uma pessoa que sobrevive com uma renda inferior a US $ 2 por dia é definida como vivendo em "pobreza absoluta". Nós adicionamos essa variável à tabela de dados:


```{r}
gapminder <- gapminder %>% mutate(dollars_per_day = gdp/population/365)
```

Os valores do PIB são ajustados pela inflação e representam o dólar atual, portanto esses valores devem ser comparáveis ao longo dos anos. Obviamente, essas são as médias dos países e dentro de cada país há muita variabilidade. Todos os gráficos e idéias descritos abaixo se referem às médias dos países e não aos indivíduos dentro deles.

### Transformação logarítmica

Abaixo está um histograma de ganhos diários de 1970:

```{r dollars-per-day-distribution}
past_year <- 1970
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black")
```

Nós usamos o argumento `color = "black"` traçar um limite e distinguir claramente os compartimentos.

Neste gráfico, vemos que para a maioria dos países, as médias estão abaixo de \$10 por día. Sin embargo, la mayoría del eje-x está dedicado a `r filter(gapminder, year == past_year & !is.na(gdp)) %>% summarise(x = sum(dollars_per_day>10)) %>% pull(x)` países con promedio de menos de \$ 10. Portanto, o gráfico não é muito informativo em relação aos países com valores abaixo de \$ 10 por dia.

Seria mais informativo ver rapidamente quantos países têm renda média diária de cerca de $1 (extremadamente pobre), \$ 2 (muito ruim), \$4 (pobre), \$ 8 (média), \$16 (acomodado), \$ 32 (rico), \$ 64 (muito rico) por dia. Essas mudanças são multiplicativas, e as transformações logarítmicas convertem as alterações multiplicativas em aditivos: quando a base 2 é usada, dobrar um valor se torna um aumento de 1.

Aqui está a distribuição se aplicarmos uma transformação logarítmica de base 2:
```{r dollars-per-day-distribution-log}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(log2(dollars_per_day))) +
geom_histogram(binwidth = 1, color = "black")
```

É assim que observamos mais de perto os países de renda média e baixa.

### Qual base?

No caso anterior, usamos a base 2 nas transformações logarítmicas. Outras opções comuns são básicas $\mathrm{e}$ (o logaritmo natural) e base 10.

Em geral, não recomendamos o uso do logaritmo natural para exploração e visualização de dados. A razão é porque enquanto $2^2, 2^3, 2^4, \dots$ ou $10^2, 10^3, \dots$ eles são fáceis de calcular em nossas cabeças, o mesmo não é verdade para $\mathrm{e}^2, \mathrm{e}^3, \dots$ portanto, a escala não é intuitiva nem fácil de interpretar.

No exemplo de dólares por dia, usamos a base 2 em vez da base 10 porque o intervalo resultante é mais fácil de interpretar. O intervalo dos valores plotados é `r with(filter(gapminder, year==past_year), range(dollars_per_day, na.rm=TRUE))`.

Na base 10, isso se torna um intervalo que inclui muito poucos números inteiros: apenas 0 e 1. Com a base dois, nosso intervalo inclui -2, -1, 0, 1, 2, 3, 4 e 5. É mais fácil de calcular $2^x$ e $10^x$ quando $x$ é um número inteiro e está entre -10 e 10, portanto, preferimos ter números inteiros menores na escala. Outra conseqüência de um intervalo limitado é que escolher a largura da bandeja (_binwidth_ em inglês) é mais difícil. Com o log de base 2, sabemos que uma largura de compartimento de 1 se tornará um compartimento com alcance $x$ para $2x$.

Para um exemplo em que a base 10 faz mais sentido, considere o tamanho da população. Um logaritmo de base 10 é preferível, pois o intervalo para eles é:

```{r}
filter(gapminder, year == past_year) %>%
summarize(min = min(population), max = max(population))
```

Abaixo está o histograma dos valores transformados:

```{r population-histogram-log10}
gapminder %>%
filter(year == past_year) %>%
ggplot(aes(log10(population))) +
geom_histogram(binwidth = 0.5, color = "black")
```

No gráfico acima, vemos rapidamente que as populações dos países variam entre dez bilhões e dez bilhões.

### Transformar valores ou escala?

Existem duas maneiras de usar transformações logarítmicas em gráficos. Podemos pegar o logaritmo dos valores antes de representá-los graficamente ou usar escalas logarítmicas nos eixos. Ambas as abordagens são úteis e têm vantagens diferentes. Se tomarmos o logaritmo dos dados, podemos interpretar mais facilmente os valores intermediários na escala. Por exemplo, se virmos:

`----1----x----2--------3----`

para dados transformados com o logaritmo, sabemos que o valor de $x$ é aproximadamente 1,5. Se usarmos escalas logarítmicas:

`----1----x----10------100---`

para determinar `x` precisamos calcular $10^{1.5}$, o que não é fácil de fazer mentalmente. A vantagem de usar escalas logarítmicas é que vemos os valores originais nos eixos. No entanto, a vantagem de exibir escalas logarítmicas é que os valores originais são mostrados no gráfico e são mais fáceis de interpretar. Por exemplo, veríamos "US $ 32 por dia" em vez de "5 bases de log US $ 2 por dia".

Como aprendemos anteriormente, se queremos escalar o eixo com logaritmos, podemos usar a função `scale_x_continuous`. Em vez de primeiro pegar o logaritmo dos valores, aplicamos esta camada:

```{r dollars-per-day-log-scale}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2")
```

Observe que a transformação logarítmica da base 10 tem sua própria função: `scale_x_log10()`, mas atualmente a base 2 não, embora possamos definir facilmente uma.

Outras transformações estão disponíveis através do argumento `trans`. Como aprenderemos mais adiante, a transformação da raiz quadrada ( `sqrt`) é útil ao considerar contagens. A transformação logística ( `logit`) é útil ao plotar proporções entre 0 e 1. A transformação `reverse` é útil quando queremos que os menores valores estejam à direita ou acima.

## Como visualizar distribuições multimodais

No histograma acima, vemos dois solavancos: um aos 4 e outro aos 32. Estatisticamente, esses solos às vezes são chamados de _modes_. O modo de uma distribuição é o valor com a frequência mais alta. O modo de distribuição normal é a média. Quando uma distribuição, como a acima, não diminui monotonicamente na moda, chamamos os lugares onde ela sobe e desce novamente - moda local - e dizemos que a distribuição tem - moda múltipla.

O histograma acima sugere que a distribuição de renda dos países em 1970 possui dois modos: um de aproximadamente US $ 2 por dia (1 na escala log 2) e outro de aproximadamente US $ 32 por dia (5 na escala log 2) . Essa bimodalidade é consistente com um mundo dicotômico composto por países com renda média inferior a US $ 8 (3 na escala log 2) por dia e países acima disso.

## Como comparar várias distribuições com gráficos de caixas e gráficos _ridge_

De acordo com o histograma, os valores da distribuição de renda para 1970 mostram uma dicotomia. No entanto, o histograma não nos mostra se os dois grupos de países estão no oeste ou em parte do mundo em desenvolvimento.

Vamos começar analisando rapidamente os dados por região. Reorganizamos as regiões pela mediana e usamos uma escala logarítmica.

```{r}
gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
mutate(region = reorder(region, dollars_per_day, FUN = median)) %>%
ggplot(aes(dollars_per_day, region)) +
geom_point() +
scale_x_continuous(trans = "log2")
```

Já podemos ver que existe de fato uma dicotomia "oeste versus o resto": existem dois grupos claros, com o rico grupo constituído pela América do Norte, Europa do Norte e Ocidental, Nova Zelândia e Austrália. Definimos grupos com base nesta observação:

```{r}
gapminder <- gapminder %>%
mutate(group = case_when(
region %in% c("Western Europe", "Northern Europe","Southern Europe",
"Northern America",
"Australia and New Zealand") ~ "West",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region %in% c("Caribbean", "Central America",
"South America") ~ "Latin America",
continent == "Africa" &
region != "Northern Africa" ~ "Sub-Saharan",
TRUE ~ "Others"))
```

Nós convertemos essa variável `group` em um fator para controlar a ordem dos níveis:

```{r}
gapminder <- gapminder %>%
mutate(group = factor(group, levels = c("Others", "Latin America",
"East Asia", "Sub-Saharan",
"West")))
```


Na próxima seção, mostramos como visualizar e comparar distribuições entre grupos.

### Diagrama de caixa

A análise exploratória dos dados acima revelou duas características sobre a distribuição de renda média em 1970. Usando um histograma, encontramos uma distribuição bimodal com modos relacionados a países ricos e pobres. Agora, queremos comparar a distribuição entre esses cinco grupos para confirmar a dicotomia "oeste versus repouso". O número de pontos em cada categoria é grande o suficiente para que um gráfico de resumo possa ser útil. Poderíamos gerar cinco histogramas ou cinco gráficos de densidade, mas pode ser mais prático ter todos os resumos visuais em um gráfico. Portanto, começamos empilhando diagramas de caixas um ao lado do outro. Observe que adicionamos a camada `theme(axis.text.x = element_text(angle = 90, hjust = 1))` para que os rótulos dos grupos sejam verticais, pois não cabem se os mostrarmos horizontalmente e para removê-los do eixo para liberar espaço.


```{r dollars-per-day-boxplot}
p <- gapminder %>%
filter(year == past_year & !is.na(gdp)) %>%
ggplot(aes(group, dollars_per_day)) +
geom_boxplot() +
scale_y_continuous(trans = "log2") +
xlab("") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
p
```

Os diagramas de caixa têm a limitação de que, resumindo os dados em cinco números, recursos importantes dos dados podem ser perdidos. Uma maneira de evitar isso é exibindo os dados.

```{r dollars-per-day-boxplot-with-data}
p + geom_point(alpha = 0.5)
```


Gráficos ### _ridge_

Mostrar cada ponto individual nem sempre revela características importantes da distribuição. Embora esse não seja o caso aqui, quando o número de pontos de dados é muito grande, acabamos sobrescrevendo e exibindo os dados pode sair pela culatra. Os diagramas de caixa ajudam nisso, fornecendo um resumo de cinco números, mas isso também tem limitações. Por exemplo, gráficos de caixa não revelam distribuições bimodais. Para ver isso, observe os dois gráficos abaixo que resumem o mesmo conjunto de dados:

```{r boxplot-dont-show-bimodal, warning=FALSE, out.width="100%", message = FALSE, echo=FALSE, fig.height=3}
set.seed(1987)
z <- sample(c(0,1), 1000, replace = TRUE, prob = c(0.25, 0.75))
x <- rnorm(100)*z + rnorm(100, 5)*(1 - z)
p1 <- qplot(x, geom = "density", fill = 1, show.legend=FALSE, alpha = 0.2) +
scale_x_continuous(limits=c(-4,8.5))
p2 <- qplot("", x, geom="boxplot")
gridExtra::grid.arrange(p1, p2, nrow = 1)
```

Nos casos em que estamos preocupados que o resumo do gráfico de caixa seja muito simplista, podemos exibir densidades suaves ou histogramas empilhados usando _ridge graphs_. Como estamos acostumados a visualizar densidades com valores no eixo x, as empilhamos verticalmente. Além disso, como precisamos de mais espaço nessa abordagem, é conveniente cobri-los. O pacote __ggridges__ inclui uma função conveniente para fazer isso. Abaixo estão os dados da receita, mostrados acima com gráficos de caixa, mas agora exibidos com uma crista gráfica _.

```{r ridge-plot, message=FALSE}
library(ggridges)
p <- gapminder %>%
filter(year == past_year & !is.na(dollars_per_day)) %>%
ggplot(aes(dollars_per_day, group)) +
scale_x_continuous(trans = "log2")
p + geom_density_ridges()
```

Lembre-se de que precisamos investir o `x` e `y` que foram usados para o gráfico da caixa. Um parâmetro útil de `geom_density_ridges` é `scale`, o que lhes permite determinar quanto se sobrepõem; por exemplo, `scale = 1` significa que não há sobreposição. Valores maiores que 1 resultam em maior sobreposição.

Se o número de pontos de dados for pequeno o suficiente, podemos adicioná-los ao gráfico _ridge_ usando o seguinte código:

```{r ridge-plot-with-points, message=FALSE}
p + geom_density_ridges(jittered_points = TRUE)
```

Por padrão, a altura dos pontos é _jittered_ e não deve ser interpretada de forma alguma. Para exibir pontos de dados, mas sem usar _jitter_, podemos usar o código a seguir para adicionar o que é conhecido como uma representação _rug_ dos dados.
```{r ridge-plot-with-rug, message=FALSE}
p + geom_density_ridges(jittered_points = TRUE,
position = position_points_jitter(height = 0),
point_shape = '|', point_size = 3,
point_alpha = 1, alpha = 0.7)
```


### Exemplo: distribuições de renda 1970 versus 2010

A exploração dos dados mostra claramente que em 1970 havia uma dicotomia "oeste versus o resto". Mas essa dicotomia persiste? Vamos usar `facet_grid` para ver como as distribuições mudaram. Para começar, focamos em dois grupos: o oeste e o resto. Fazemos quatro histogramas.

```{r income-hist-west-v-developing-two-years}
past_year <- 1970
present_year <- 2010
years <- c(past_year, present_year)
gapminder %>%
filter(year %in% years & !is.na(gdp)) %>%
mutate(west = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2") +
facet_grid(year ~ west)
```

Antes de interpretar as conclusões deste gráfico, notamos que há mais países representados nos histogramas de 2010 do que em 1970: a contagem total é maior. Uma razão para isso é que vários países foram fundados após 1970. Por exemplo, a União Soviética foi dividida em diferentes países durante os anos 90. Outra razão é que mais dados estão disponíveis para mais países em 2010.

Nós refizemos os gráficos usando apenas países com dados disponíveis para os dois anos. Na parte _data wrangling_ deste livro, aprenderemos como usar as ferramentas __tidyverse__ que nos permitirão escrever código eficiente para isso, mas aqui podemos usar código simples usando a função `intersect`:

```{r}
country_list_1 <- gapminder %>%
filter(year == past_year & !is.na(dollars_per_day)) %>%
pull(country)

country_list_2 <- gapminder %>%
filter(year == present_year & !is.na(dollars_per_day)) %>%
pull(country)

country_list <- intersect(country_list_1, country_list_2)
```

Estes `r length(country_list)` constituir
`r round(gapminder %>% filter(year==present_year) %>% summarize(perc=sum(population[country%in%country_list], na.rm=TRUE)/sum(population, na.rm=TRUE)) %>% pull(perc)*100 )`% da população mundial, portanto esse subconjunto deve ser representativo.

Vamos refazer o gráfico, mas apenas para este subconjunto simplesmente adicionando `country %in% country_list` para a função `filter`:

```{r income-histogram-west-v-devel, echo=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(west = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day)) +
geom_histogram(binwidth = 1, color = "black") +
scale_x_continuous(trans = "log2") +
facet_grid(year ~ west)
```

Agora vemos que os países ricos ficaram um pouco mais ricos, mas em termos de porcentagem, os países pobres parecem ter melhorado mais. Em particular, vemos que a proporção de países em desenvolvimento que ganha mais de US $ 16 por dia aumentou substancialmente.

Para ver quais regiões específicas melhoraram mais, podemos refazer os boxplots que fizemos anteriormente, mas agora adicionamos o ano de 2010 e usamos _facet_ para comparar os dois anos.


```{r income-histogram-by-region, out.width="100%"}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
ggplot(aes(group, dollars_per_day)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
xlab("") +
facet_grid(. ~ year)
```

Aqui, fazemos uma pausa para introduzir outro recurso importante do __ggplot2__. Como queremos comparar cada região antes e depois, seria conveniente ter o diagrama de caixa de `r past_year` próximo ao de `r present_year` para cada região. Em geral, as comparações são mais fáceis quando os dados são plotados um ao lado do outro.

Portanto, em vez de nos separarmos em facetas, mantemos os dados de cada ano juntos e pedimos para colorir (ou preenchê-los) por ano. Observe que os grupos são separados automaticamente por ano e cada par de diagramas de caixas é desenhado lado a lado. Como o ano é um número, nós o tornamos um fator, já que __ggplot2__ atribui automaticamente uma cor a cada categoria de um fator. Lembre-se que temos que converter as colunas `year` de numérico para fator.

```{r income-histogram-west-v-devel-by-year}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(year = factor(year)) %>%
ggplot(aes(group, dollars_per_day, fill = year)) +
geom_boxplot() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
scale_y_continuous(trans = "log2") +
xlab("")
```

Finalmente, destacamos que, se estivermos mais interessados em comparar os valores antes e depois, pode fazer mais sentido traçar aumentos percentuais. Ainda não estamos prontos para aprender como codificar isso, mas é assim que o gráfico seria:

```{r income-west-v-devel-before-after-ratio, echo=FALSE, warning=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(year = ifelse(year == past_year, "past", "present")) %>%
select(country, group, year, dollars_per_day) %>%
spread(year, dollars_per_day) %>%
mutate(percent_increase = (present-past)/past*100) %>%
mutate(group = reorder(group, percent_increase, FUN = median)) %>%
ggplot(aes(group, percent_increase)) +
geom_boxplot() +
geom_point(show.legend = FALSE) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
xlab("") +
ylab(paste("Percent increase:", past_year, "to", present_year))
```


A exploração de dados anteriores sugere que a diferença de renda entre países ricos e pobres diminuiu consideravelmente nos últimos 40 anos. Usamos uma série de histogramas e gráficos de caixa para ver isso. Sugerimos uma maneira sucinta de transmitir essa mensagem com apenas um gráfico.

Vamos começar observando que os gráficos de densidade para a distribuição de renda em `r past_year` e `r present_year` eles transmitem a mensagem de que a lacuna está se fechando:

```{r income-smooth-density-by-year, out.width="100%", fig.height=3}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
ggplot(aes(dollars_per_day)) +
geom_density(fill = "grey") +
scale_x_continuous(trans = "log2") +
facet_grid(. ~ year)
```

No gráfico de `r past_year` vemos duas tendências claras: países pobres e ricos. No `r present_year` alguns dos países pobres parecem ter mudado para a direita, diminuindo a diferença.

A próxima mensagem que devemos transmitir é que a razão para essa mudança na distribuição é que vários países pobres ficaram mais ricos do que alguns países ricos ficaram mais pobres. Para fazer isso, podemos atribuir uma cor aos grupos que identificamos durante a exploração de dados.

No entanto, precisamos primeiro aprender a suavizar essas densidades de maneira a preservar informações sobre o número de países em cada grupo. Para entender por que precisamos disso, lembre-se da discrepância no tamanho de cada grupo:

```{r, echo=FALSE}
tmp <- gapminder %>%
filter(year == past_year & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
group_by(group) %>%
summarize(n=n()) %>%
spread(group, n)
if(knitr::is_html_output()){
knitr::kable(tmp, "html") %>%
kableExtra::kable_styling(bootstrap_options = "striped", full_width = FALSE)
} else{
knitr::kable(tmp, "latex", booktabs = TRUE) %>%
kableExtra::kable_styling(font_size = 8)
}
```

Porém, quando sobrepomos duas densidades, o comportamento padrão é que a área representada por cada distribuição some 1, independentemente do tamanho de cada grupo:

```{r income-smooth-density-by-year-west-v-developing}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day, fill = group)) +
scale_x_continuous(trans = "log2") +
geom_density(alpha = 0.2) +
facet_grid(year ~ .)
```

O gráfico acima mostra que há o mesmo número de países em cada grupo. Para mudar isso, precisaremos aprender como acessar as variáveis calculadas com a função `geom_density`.

### Como acessar variáveis calculadas

Para tornar as áreas dessas densidades proporcionais ao tamanho do grupo, simplesmente multiplicamos os valores do eixo y pelo tamanho do grupo. No arquivo de ajuda de `geom_density`, vemos que as funções calculam uma variável chamada `count` quem faz exatamente isso. Queremos que essa variável, e não a densidade, esteja no eixo y.

Em __ggplot2__, obtemos acesso a essas variáveis cercando o nome com dois pontos. Portanto, usaremos o seguinte mapeamento:

```{r, eval=FALSE}
aes(x = dollars_per_day, y = ..count..)
```

Agora podemos criar o diagrama desejado simplesmente alterando o mapeamento no snippet de código acima. Também estenderemos os limites do eixo x.


```{r income-smooth-density-counts}
p <- gapminder %>%
filter(year %in% years & country %in% country_list) %>%
mutate(group = ifelse(group == "West", "West", "Developing")) %>%
ggplot(aes(dollars_per_day, y = ..count.., fill = group)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300))

p + geom_density(alpha = 0.2) +
facet_grid(year ~ .)
```

Se queremos que as densidades sejam mais suaves, usamos o argumento `bw` para que o mesmo parâmetro de suavização seja usado para cada densidade. Selecionamos 0,75 após testar vários valores.

```{r income-smooth-density-counts-by-year}
p + geom_density(alpha = 0.2, bw = 0.75) + facet_grid(year ~ .)
```

Este gráfico agora mostra o que está acontecendo muito claramente. A distribuição do mundo em desenvolvimento está mudando. Uma terceira tendência aparece, composta pelos países que mais diminuíram a diferença.

Para visualizar se algum dos grupos definidos acima é a principal causa dessas alterações, podemos criar rapidamente um gráfico _ridge_:

```{r ridge-plot-income-five-regions, warning=FALSE, message=FALSE}
gapminder %>%
filter(year %in% years & !is.na(dollars_per_day)) %>%
ggplot(aes(dollars_per_day, group)) +
scale_x_continuous(trans = "log2") +
geom_density_ridges(adjust = 1.5) +
facet_grid(. ~ year)
```

Outra maneira de conseguir isso é empilhando as densidades umas sobre as outras:

```{r income-smooth-density-counts-by-region-and-year}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
group_by(year) %>%
mutate(weight = population/sum(population)*2) %>%
ungroup() %>%
ggplot(aes(dollars_per_day, fill = group)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300)) +
geom_density(alpha = 0.2, bw = 0.75, position = "stack") +
facet_grid(year ~ .)
```

Aqui podemos ver claramente como as distribuições para o leste da Ásia, América Latina e outros se deslocam visivelmente para a direita. Enquanto a África subsaariana permanece estagnada.

Observe que ordenamos os níveis do grupo para que a densidade do Ocidente seja grafada primeiro, depois na África Subsaariana. Tendo ambas as extremidades representadas graficamente primeiro, permite-nos ver melhor a bimodalidade restante.


### Densidades ponderadas

Como ponto final, notamos que essas distribuições pesam cada país igualmente. Portanto, se a maioria da população está melhorando, mas morando em um país muito grande, como a China, talvez não gostemos disso. De fato, podemos ponderar as densidades suaves usando o argumento de mapeamento `weight`. O gráfico fica assim:

```{r income-smooth-density-counts-by-region-year-weighted, warning=FALSE, echo=FALSE}
gapminder %>%
filter(year %in% years & country %in% country_list) %>%
group_by(year) %>%
mutate(weight = population/sum(population)*2) %>%
ungroup() %>%
ggplot(aes(dollars_per_day, fill = group, weight = weight)) +
scale_x_continuous(trans = "log2", limit = c(0.125, 300)) +
geom_density(alpha = 0.2, bw = 0.75, position = "stack") + facet_grid(year ~ .)
```

Esta figura em particular mostra muito claramente como a lacuna na distribuição de renda está diminuindo e que a maioria dos países ainda em situação de pobreza está na África Subsaariana.


## A falácia ecológica e a importância de mostrar os dados

Ao longo desta seção, comparamos regiões do mundo. Vimos que, em média, algumas regiões têm melhor desempenho que outras. Nesta seção, vamos nos concentrar na descrição da importância da variabilidade dentro dos grupos, examinando a relação entre as taxas de mortalidade infantil de um país e a renda média.

Definimos mais algumas regiões e comparamos as médias entre as regiões:

```{r ecological-fallacy-averages, echo=FALSE}
gapminder <- gapminder %>%
mutate(group = case_when(
region %in% c("Western Europe", "Northern Europe",
"Southern Europe", "Northern America",
"Australia and New Zealand") ~ "West",
region %in% "Northern Africa" ~ "Northern Africa",
region %in% c("Eastern Asia", "South-Eastern Asia") ~ "East Asia",
region == "Southern Asia"~ "Southern Asia",
region %in% c("Central America", "South America",
"Caribbean") ~ "Latin America",
continent == "Africa" &
region != "Northern Africa" ~ "Sub-Saharan",
region %in% c("Melanesia", "Micronesia",
"Polynesia") ~ "Pacific Islands"))
surv_income <- gapminder %>%
filter(year %in% present_year & !is.na(gdp) &
!is.na(infant_mortality) & !is.na(group)) %>%
group_by(group) %>%
summarize(income = sum(gdp)/sum(population)/365,
infant_survival_rate =
1 - sum(infant_mortality/1000*population)/sum(population))

#surv_income %>% arrange(income) %>% print(n=nrow(surv_income))

surv_income %>% ggplot(aes(income, infant_survival_rate, label = group, color = group)) +
scale_x_continuous(trans = "log2", limits = c(0.25, 150)) +
scale_y_continuous(trans = "logit", limit = c(0.875, .9981),
breaks = c(.85,.90,.95,.99,.995,.998)) +
geom_label_repel(size = 3, show.legend = FALSE)
```

A relação entre essas duas variáveis é quase perfeitamente linear e o gráfico mostra uma diferença dramática. Enquanto menos de 0,5% dos bebês morrem no Ocidente, na África Subsaariana a taxa é superior a 6%!

Observe que o gráfico usa uma nova transformação, a transformação logística.

### Transformação de logística {#logit}
Transformação logística ou _logit_ para uma proporção ou taxa $p$ é definido como:

$$f(p) = \log \left( \frac{p}{1-p} \right)$$

Quando $p$ é uma proporção ou probabilidade, a quantidade que transformamos com o logaritmo, $p/(1-p)$, é chamado _odds_. Neste caso $p$ é a proporção de bebês que sobreviveram. Os filhos nos dizem quantos mais bebês devem sobreviver à morte. A transformação logarítmica torna simétrica. Se as taxas forem iguais, as _log odds_ serão 0. Aumentos multiplicativos são convertidos em aumentos positivos ou negativos, respectivamente.

Essa escala é útil quando queremos destacar diferenças próximas de 0 ou 1. Para taxas de sobrevivência, isso é importante porque uma taxa de sobrevivência de 90% é inaceitável, enquanto uma sobrevivência de 99% é relativamente boa. Preferiríamos muito uma taxa de sobrevivência próxima de 99,9%. Queremos que nossa escala destaque essas diferenças e o _logit_ o faz. Lembre-se de que 99,9/ 0,1 é aproximadamente 10 vezes maior que 99/1, que é aproximadamente 10 vezes maior que 90/10. Usando o logaritmo, esses incrementos multiplicativos são convertidos em aumentos constantes.

### Mostrar os dados

Agora, de volta ao nosso gráfico. Com base no gráfico acima, concluímos que um país de baixa renda está destinado a ter uma baixa taxa de sobrevivência? Além disso, concluímos que as taxas de sobrevivência na África subsaariana são mais baixas do que no sul da Ásia, que por sua vez são mais baixas do que nas ilhas do Pacífico e assim por diante?

Saltar para esta conclusão com base em um gráfico mostrando médias é chamado de _falácia ecológica_. A relação quase perfeita entre taxas de sobrevivência e renda é observada apenas para médias regionais. Depois de mostrar todos os dados, vemos uma história mais complicada:

```{r ecological-fallacy-all-data, echo=FALSE}
library(ggrepel)
highlight <- c("Sierra Leone", "Mauritius", "Sudan", "Botswana", "Tunisia",
"Cambodia","Singapore","Chile", "Haiti", "Bolivia",
"United States","Sweden", "Angola", "Serbia")

gapminder %>% filter(year %in% present_year & !is.na(gdp) & !is.na(infant_mortality) & !is.na(group) ) %>%
mutate(country_name = ifelse(country %in% highlight, as.character(country), "")) %>%
ggplot(aes(dollars_per_day, 1 - infant_mortality/1000, col = group, label = country_name)) +
scale_x_continuous(trans = "log2", limits=c(0.25, 150)) +
scale_y_continuous(trans = "logit",limit=c(0.875, .9981),
breaks=c(.85,.90,.95,.99,.995,.998)) +
geom_point(alpha = 0.5, size = 3) +
geom_text_repel(size = 4, show.legend = FALSE)
```

Especificamente, vemos que há muita variabilidade. Vemos que os países nas mesmas regiões podem ser bem diferentes e que os países com a mesma renda podem ter taxas de sobrevivência diferentes. Por exemplo, enquanto a África Subsaariana teve os piores resultados econômicos e de saúde em média, há uma grande variabilidade dentro desse grupo. Maurício e Botsuana são melhores que Angola e Serra Leoa, com Maurício comparável aos países ocidentais.





